import sys, os
sys.path.append(os.path.dirname(__file__))

import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

from memory import Memory
from reflection.reflection import Reflection

class Experience(Memory):

    def __init__(self, children:list = []):
        self.__children = children
        self.__decay = 0.005
        self.__max_importance = 5
        self.__alpha = 1
        self.__max_retrieval = 3

        self.__recent_importance = self.calculate_importance().sum()
        self.__tfidf = TfidfVectorizer(stop_words='english')

    def retrieval(self, description):
        self.__description = description
        self.__new_reflection()

        result = np.concatenate((self.calculate_recency(self.__decay) * self.__alpha,
                                self.calculate_importance()* self.__alpha,
                                self.calculate_relevance()* self.__alpha), axis=1)
        result_sum = enumerate(result.sum(axis=1))
        result_sorted = sorted(result_sum, key=lambda x: x[1], reverse=True)
        indexes = result_sorted[:self.__max_retrieval]
        
        return self.__get_childs(
            [index for index, value in indexes]
        )

    def calculate_recency(self, decay):
        return np.array([[child.calculate_recency(decay)] for child in self.__children])

    def calculate_importance(self):
        return np.array([[child.calculate_importance()] for child in self.__children])

    def calculate_relevance(self):
        description_list = [child.calculate_relevance() for child in self.__children]
        description_list.append(self.__description)

        tfidf_matrix = self.__tfidf.fit_transform(description_list)
        cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)
        
        sim_scores = cosine_sim[cosine_sim.shape[0] - 1][:cosine_sim.shape[1] - 1]

        return np.expand_dims(sim_scores, axis=1)

    def append_memory(self, memory:Memory):
        self.__recent_importance += memory.calculate_importance()
        self.__children.append(memory)

    def __new_reflection(self):
        if self.__recent_importance >= self.__max_importance:
            self.__recent_importance = 0
            #TODO:
            #Get the 100 most recent observations
            #Give it plus the question to the model
            #What 5 high-level insights can you infer from the above statments?
            #The description and selected observations most be generated by a model
            observation_pointer = [
                self.__children[1],
                self.__children[2],
                self.__children[7]
            ]
            self.__children.append(Reflection("Eliza loves the sea.", importance=8, pointers=observation_pointer))

    def __get_childs(self, indexes):
        nodes = []
        for index in indexes:
            self.__children[index].calculate_recent_access()
            nodes.append(self.__children[index].calculate_relevance())
        return nodes

    def __str__(self):
        return '%s Tree: has %d children and a decay of %d' % (self.__class__.__name__,len(self.__children), self.__decay)